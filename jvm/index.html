<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>JVM | Zachary&#39;s Home</title>
<link rel="shortcut icon" href="https://zacharyzekaichen.github.io/favicon.ico?v=1608366219795">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://zacharyzekaichen.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="JVM | Zachary&#39;s Home - Atom Feed" href="https://zacharyzekaichen.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="[toc]
双亲委派机制
优势

避免类的重复加载
保护线程安全，防止核心API被随意篡改

java.lang.String
java.lang.ShkStart



沙箱安全机制
保证对java核心源代码的保护。
其他
JVM中表示两..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://zacharyzekaichen.github.io">
  <img class="avatar" src="https://zacharyzekaichen.github.io/images/avatar.png?v=1608366219795" alt="">
  </a>
  <h1 class="site-title">
    Zachary&#39;s Home
  </h1>
  <p class="site-description">
    Growth
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          Home
        </a>
      
    
      
        <a href="/archives" class="menu">
          Notes
        </a>
      
    
      
        <a href="/tags" class="menu">
          Tags
        </a>
      
    
      
        <a href="/post/about" class="menu">
          About
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              JVM
            </h2>
            <div class="post-info">
              <span>
                2020-12-02
              </span>
              <span>
                3 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>[toc]</p>
<h3 id="双亲委派机制">双亲委派机制</h3>
<h4 id="优势">优势</h4>
<ul>
<li>避免类的重复加载</li>
<li>保护线程安全，防止核心API被随意篡改
<ul>
<li>java.lang.String</li>
<li>java.lang.ShkStart</li>
</ul>
</li>
</ul>
<h3 id="沙箱安全机制">沙箱安全机制</h3>
<p>保证对java核心源代码的保护。</p>
<h3 id="其他">其他</h3>
<h4 id="jvm中表示两个class对象是否为同一个类存在的两个必要条件">JVM中表示两个class对象是否为同一个类存在的两个必要条件</h4>
<ul>
<li>类的完整类名必须一样，包括包名。</li>
<li>加载的ClassLoader必须相同。</li>
</ul>
<p><mark>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在<strong>方法区</strong>中。</mark></p>
<h4 id="主动使用和被动使用">主动使用和被动使用</h4>
<p>两者的区别是：类的被动使用不会导致<mark>类的初始化</mark>。</p>
<h2 id="运行时数据区概述及线程">运行时数据区概述及线程</h2>
<h3 id="简单介绍">简单介绍</h3>
<p>JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<mark>不同的JVM对于内存的划分方式和管理机制存在着部分差异。</mark></p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5Czacha%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201203230740457.png" alt="image-20201203230740457" loading="lazy"></figure>
<p>Java虚拟机的启动和退出与一个进程相对应。</p>
<p>重点优化的是堆空间[95%]和方法区（元空间）[5%]。</p>
<p>一个JVM的内存区域对应一个Runtime类的对象。</p>
<h3 id="线程">线程</h3>
<p>线程是一个程序里的运行单元。</p>
<p>在Hotspot JVM里，<mark>每个线程都与操作系统的本地线程直接映射</mark>。当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建，调用Java线程中的run()方法。Java线程执行终止后，本地线程也会回收。</p>
<p>后台系统线程：</p>
<figure data-type="image" tabindex="2"><img src="C:%5CUsers%5Czacha%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201203232037475.png" alt="image-20201203232037475" loading="lazy"></figure>
<h3 id="程序计数器pc寄存器">程序计数器（PC寄存器）</h3>
<h4 id="介绍">介绍</h4>
<p><mark>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。<mark>也称为</mark>程序钩子</mark>。</p>
<p>作用：用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p>
<p>任何时间一个线程都只有一个方法在执行，也就是所谓的<mark>当前方法</mark>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法（本地方法区），则是未指定值（undefined）。</p>
<p><mark>它是唯一一个Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。<strong>其实是，既没有OOM，也没有GC。</strong></mark></p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6">双亲委派机制</a>
<ul>
<li><a href="#%E4%BC%98%E5%8A%BF">优势</a></li>
</ul>
</li>
<li><a href="#%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6">沙箱安全机制</a></li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a>
<ul>
<li><a href="#jvm%E4%B8%AD%E8%A1%A8%E7%A4%BA%E4%B8%A4%E4%B8%AAclass%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E5%90%8C%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AD%98%E5%9C%A8%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6">JVM中表示两个class对象是否为同一个类存在的两个必要条件</a></li>
<li><a href="#%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8">主动使用和被动使用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B">运行时数据区概述及线程</a>
<ul>
<li><a href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D">简单介绍</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B">线程</a></li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8pc%E5%AF%84%E5%AD%98%E5%99%A8">程序计数器（PC寄存器）</a>
<ul>
<li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://zacharyzekaichen.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
